<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Container Map Shooter</title>
<style>
  canvas { background: #112233; display: block; margin: 0 auto; }
  #pauseMenu {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    font-family: sans-serif;
    padding: 20px 40px;
    border-radius: 10px;
    display: none;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<div id="pauseMenu">PAUSED<br><br>Press ESC to Resume</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Game state
  let paused = false;

  // Player
  const player = {
    x: 50,
    y: 50,
    width: 30,
    height: 30,
    color: 'lime',
    speed: 3,
    health: 100,
    alive: true
  };

  // Containers (map obstacles)
  const containers = [
    {x: 200, y: 100, width: 100, height: 50, color: '#b34700'}, // rusty orange container
    {x: 400, y: 200, width: 150, height: 70, color: '#0055ff'}, // blue container
    {x: 600, y: 100, width: 80, height: 120, color: '#aa0044'}, // red container
    {x: 300, y: 400, width: 120, height: 60, color: '#339933'}, // green container
    // Add more containers here
  ];

  // Bullets (player and enemies)
  const bullets = [];

  // Enemies
  const enemies = [];
  const enemySpawnPoints = [
    {x: 700, y: 500},
    {x: 650, y: 150},
    {x: 550, y: 400},
  ];

  // Create initial enemies
  enemySpawnPoints.forEach(sp => spawnEnemy(sp.x, sp.y));

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    if(e.key === 'Escape') {
      togglePause();
    }
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Pause menu element
  const pauseMenu = document.getElementById('pauseMenu');

  function togglePause() {
    paused = !paused;
    pauseMenu.style.display = paused ? 'block' : 'none';
  }

  // Collision detection (AABB)
  function rectsCollide(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
  }

  // Move player with collision detection
  function movePlayer(dx, dy) {
    if(!player.alive) return;

    const newX = player.x + dx;
    const newY = player.y + dy;

    // Check collision with containers
    const playerRect = {...player, x: newX, y: newY};
    for(let c of containers) {
      if(rectsCollide(playerRect, c)) {
        return; // blocked, don't move
      }
    }
    // Check bounds
    if(newX < 0 || newX + player.width > WIDTH) return;
    if(newY < 0 || newY + player.height > HEIGHT) return;

    player.x = newX;
    player.y = newY;
  }

  // Player shooting
  function shootBullet(fromX, fromY, targetX, targetY, owner) {
    const angle = Math.atan2(targetY - fromY, targetX - fromX);
    const speed = 6;
    bullets.push({
      x: fromX,
      y: fromY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      radius: 5,
      color: owner === 'player' ? 'lime' : 'red',
      owner,
      alive: true
    });
  }

  // Spawn enemy function
  function spawnEnemy(x, y) {
    enemies.push({
      x, y,
      width: 30,
      height: 30,
      color: 'red',
      speed: 1.5,
      health: 50,
      alive: true,
      shootCooldown: 0,
    });
  }

  // Enemy AI
  function updateEnemies(delta) {
    enemies.forEach((enemy, index) => {
      if(!enemy.alive) return;

      // Move towards player if alive
      const dx = player.x - enemy.x;
      const dy = player.y - enemy.y;
      const dist = Math.hypot(dx, dy);
      if(dist > 5) {
        const moveX = (dx / dist) * enemy.speed;
        const moveY = (dy / dist) * enemy.speed;

        // Collision check with containers for enemy
        const newEnemyRect = {...enemy, x: enemy.x + moveX, y: enemy.y + moveY};
        let blocked = false;
        for(let c of containers) {
          if(rectsCollide(newEnemyRect, c)) {
            blocked = true;
            break;
          }
        }
        if(!blocked) {
          enemy.x += moveX;
          enemy.y += moveY;
        }
      }

      // Enemy shoot cooldown
      enemy.shootCooldown -= delta;
      if(enemy.shootCooldown <= 0 && enemy.alive) {
        // Shoot at player
        shootBullet(enemy.x + enemy.width/2, enemy.y + enemy.height/2, player.x + player.width/2, player.y + player.height/2, 'enemy');
        enemy.shootCooldown = 2000; // shoot every 2 seconds
      }
    });
  }

  // Handle bullets movement and collisions
  function updateBullets(delta) {
    bullets.forEach((b, i) => {
      if(!b.alive) return;

      b.x += b.vx;
      b.y += b.vy;

      // Remove bullet if out of bounds
      if(b.x < 0 || b.x > WIDTH || b.y < 0 || b.y > HEIGHT) {
        b.alive = false;
        return;
      }

      // Check collision with containers (bullets die on container hit)
      for(let c of containers) {
        if(b.x > c.x && b.x < c.x + c.width && b.y > c.y && b.y < c.y + c.height) {
          b.alive = false;
          return;
        }
      }

      if(b.owner === 'player') {
        // Bullet hits enemies
        enemies.forEach(e => {
          if(e.alive && b.alive && b.x > e.x && b.x < e.x + e.width && b.y > e.y && b.y < e.y + e.height) {
            e.health -= 25;
            b.alive = false;
            if(e.health <= 0) {
              e.alive = false;
              // Respawn enemy after 5 seconds
              setTimeout(() => {
                // Respawn at original spawn point
                const spawnIndex = enemies.indexOf(e);
                if(spawnIndex >= 0) {
                  enemies[spawnIndex] = {
                    x: enemySpawnPoints[spawnIndex].x,
                    y: enemySpawnPoints[spawnIndex].y,
                    width: 30,
                    height: 30,
                    color: 'red',
                    speed: 1.5,
                    health: 50,
                    alive: true,
                    shootCooldown: 0,
                  };
                }
              }, 5000);
            }
          }
        });
      } else if(b.owner === 'enemy') {
        // Bullet hits player
        if(player.alive && b.alive && b.x > player.x && b.x < player.x + player.width && b.y > player.y && b.y < player.y + player.height) {
          player.health -= 10;
          b.alive = false;
          if(player.health <= 0) {
            player.alive = false;
            // Respawn player after 3 seconds without reload
            setTimeout(() => {
              player.x = 50;
              player.y = 50;
              player.health = 100;
              player.alive = true;
            }, 3000);
          }
        }
      }
    });

    // Remove dead bullets
    for(let i = bullets.length -1; i >=0; i--) {
      if(!bullets[i].alive) bullets.splice(i, 1);
    }
  }

  // Player shooting on spacebar
  window.addEventListener('keydown', e => {
    if(e.key === ' ') {
      if(!paused && player.alive) {
        // Shoot towards mouse position or forward (simple forward here)
        shootBullet(player.x + player.width/2, player.y + player.height/2, player.x + 100, player.y, 'player');
      }
    }
  });

  // Main update loop
  let lastTime = 0;
  function update(time = 0) {
    if(paused) {
      requestAnimationFrame(update);
      return;
    }
    const delta = time - lastTime;
    lastTime = time;

    // Move player
    if(player.alive) {
      if(keys['w']) movePlayer(0, -player.speed);
      if(keys['s']) movePlayer(0, player.speed);
      if(keys['a']) movePlayer(-player.speed, 0);
      if(keys['d']) movePlayer(player.speed, 0);
    }

    updateEnemies(delta);
    updateBullets(delta);

    draw();

    requestAnimationFrame(update);
  }

  // Draw function
  function draw() {
    ctx.clearRect(0,0,WIDTH,HEIGHT);

    // Draw map background
    ctx.fillStyle = '#223344';
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    // Draw containers
    containers.forEach(c => {
      ctx.fillStyle = c.color;
      ctx.fillRect(c.x, c.y, c.width, c.height);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(c.x, c.y, c.width, c.height);
    });

    // Draw player
    if(player.alive) {
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
    } else {
      ctx.fillStyle = 'rgba(0,255,0,0.3)';
      ctx.fillRect(player.x, player.y, player.width, player.height);
    }

    // Draw enemies
    enemies.forEach(e => {
      if(e.alive) {
        ctx.fillStyle = e.color;
        ctx.fillRect(e.x, e.y, e.width, e.height);
      }
    });

    // Draw bullets
    bullets.forEach(b => {
      ctx.beginPath();
      ctx.fillStyle = b.color;
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
      ctx.fill();
    });

    // Draw HUD: Health
    ctx.fillStyle = 'white';
    ctx.font = '16px sans-serif';
    ctx.fillText('Health: ' + player.health, 10, 20);
  }

  update();

})();
</script>
</body>
</html>
