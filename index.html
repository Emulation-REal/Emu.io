<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emu.io - Container Map FPS</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background-color: #1c1c1c;
    font-family: Arial, sans-serif;
    color: white;
  }
  #hud {
    position: absolute; top: 10px; left: 10px;
    z-index: 10;
    font-weight: bold;
    user-select: none;
  }
  #health {
    margin-bottom: 10px;
  }
  #bullets {
    margin-bottom: 10px;
  }
  #crosshair {
    position: absolute;
    top: 50%; left: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events: none;
    z-index: 10;
  }
  #crosshair div {
    position: absolute;
    background: white;
  }
  #crosshair div:nth-child(1) {
    top: 9px; left: 0; width: 20px; height: 2px;
  }
  #crosshair div:nth-child(2) {
    top: 0; left: 9px; width: 2px; height: 20px;
  }
  #pauseMenu {
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 100;
    flex-direction: column;
  }
  #pauseMenu button {
    background: #28a745;
    border: none;
    padding: 15px 30px;
    margin: 10px;
    font-size: 20px;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    user-select: none;
  }
  #pauseMenu button:hover {
    background: #218838;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<div id="hud">
  <div id="health">Health: 100</div>
  <div id="bullets">Bullets: 30 / 30</div>
</div>
<div id="crosshair">
  <div></div>
  <div></div>
</div>
<div id="pauseMenu">
  <h1>Game Paused</h1>
  <button id="resumeBtn">Resume</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Basic setup
  let scene, camera, renderer, controls;
  let clock = new THREE.Clock();
  const player = {
    health: 100,
    maxHealth: 100,
    speed: 5,
    canShoot: true,
    bulletsInClip: 30,
    maxBullets: 30,
    reloadTime: 2,
    reloading: false
  };

  // HUD
  const healthEl = document.getElementById('health');
  const bulletsEl = document.getElementById('bullets');
  const pauseMenu = document.getElementById('pauseMenu');
  const resumeBtn = document.getElementById('resumeBtn');

  // Crosshair is CSS divs so done

  // Controls keys
  const keys = {};

  // Entities
  const containers = [];
  const bots = [];
  const bullets = [];
  const enemyBullets = [];

  let paused = false;

  // Map dimensions
  const mapSize = 60;

  // Gravity & jumping
  let velocityY = 0;
  let onGround = false;
  const gravity = -9.8;

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x334455);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 10);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls & pointer lock
    controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    // Pointer lock on click
    renderer.domElement.addEventListener('click', () => {
      if (!paused && !controls.isLocked) controls.lock();
    });

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(mapSize, mapSize);
    const floorMaterial = new THREE.MeshStandardMaterial({color:0x556655});
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Build containers (like cod container map)
    buildContainers();

    // Spawn bots
    for(let i=0; i<8; i++) {
      spawnBot(randomPos(), randomPos());
    }

    // Gun model
    createGunModel();

    // Events
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if(e.code === 'KeyR') reloadGun();
      if(e.code === 'Escape') togglePause();
    });
    document.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousedown', e => {
      if (e.button === 0) shoot();
    });

    window.addEventListener('resize', onWindowResize);
  }

  // Build container map
  function buildContainers(){
    // Use boxes arranged like container yard
    const containerGeometry = new THREE.BoxGeometry(6,4,12);
    const containerMaterial = new THREE.MeshStandardMaterial({color:0x334466, roughness:0.7});

    // Arrange containers in rows/columns with spacing
    for(let x=-20; x<=20; x+=10){
      for(let z=-20; z<=20; z+=15){
        if(Math.abs(x)<10 && Math.abs(z)<10) continue; // leave central area free for player spawn
        const container = new THREE.Mesh(containerGeometry, containerMaterial);
        container.position.set(x,2,z);
        container.castShadow = true;
        container.receiveShadow = true;
        scene.add(container);
        containers.push(container);
      }
    }
  }

  // Create gun model and attach to camera
  let gunMesh;
  function createGunModel(){
    // Simple shape resembling a gun
    const gunGroup = new THREE.Group();

    const barrelGeo = new THREE.BoxGeometry(0.4,0.3,1.2);
    const barrelMat = new THREE.MeshStandardMaterial({color:0x555555});
    const barrel = new THREE.Mesh(barrelGeo, barrelMat);
    barrel.position.set(0.5, -0.5, -1);
    gunGroup.add(barrel);

    const handleGeo = new THREE.BoxGeometry(0.2,0.6,0.3);
    const handleMat = new THREE.MeshStandardMaterial({color:0x222222});
    const handle = new THREE.Mesh(handleGeo, handleMat);
    handle.position.set(0.5, -1.0, -0.3);
    gunGroup.add(handle);

    controls.getObject().add(gunGroup);
    gunMesh = gunGroup;
  }

  // Spawn bot
  function spawnBot(x,z){
    const geometry = new THREE.BoxGeometry(1,2,1);
    const material = new THREE.MeshStandardMaterial({color:0x440000});
    const bot = new THREE.Mesh(geometry, material);
    bot.position.set(x,1,z);
    bot.health = 100;
    bot.reloadTimer = 0;
    bot.canShoot = true;
    scene.add(bot);
    bots.push(bot);
  }

  // Random position within map bounds (except center safe zone)
  function randomPos(){
    let pos;
    do {
      pos = (Math.random()-0.5)*mapSize*0.9;
    } while (Math.abs(pos)<5);
    return pos;
  }

  // Shoot player bullet
  function shoot(){
    if(!controls.isLocked) return;
    if(player.reloading || player.bulletsInClip <=0) return;
    player.bulletsInClip--;
    updateHUD();

    // Create bullet
    const bulletGeo = new THREE.SphereGeometry(0.08,8,8);
    const bulletMat = new THREE.MeshStandardMaterial({color:0xffff00});
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);
    bullet.position.copy(camera.position);
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    bullet.velocity = dir.multiplyScalar(20);
    bullet.owner = 'player';
    scene.add(bullet);
    bullets.push(bullet);
  }

  // Reload gun
  function reloadGun(){
    if(player.reloading || player.bulletsInClip === player.maxBullets) return;
    player.reloading = true;
    setTimeout(() => {
      player.bulletsInClip = player.maxBullets;
      player.reloading = false;
      updateHUD();
    }, player.reloadTime*1000);
  }

  // Enemy shooting logic
  function botShoot(bot){
    if(!bot.canShoot || bot.health <= 0) return;
    bot.canShoot = false;
    bot.reloadTimer = 2; // 2 seconds cooldown

    // Create bullet
    const bulletGeo = new THREE.SphereGeometry(0.1,8,8);
    const bulletMat = new THREE.MeshStandardMaterial({color:0xff3300});
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);
    bullet.position.copy(bot.position).add(new THREE.Vector3(0,1,0));
    const dir = new THREE.Vector3();
    dir.subVectors(controls.getObject().position, bot.position).normalize();
    bullet.velocity = dir.multiplyScalar(15);
    bullet.owner = 'bot';
    scene.add(bullet);
    enemyBullets.push(bullet);
  }

  // Collision detection helpers
  function boxIntersect(box1, box2){
    return box1.intersectsBox(box2);
  }

  // Check collisions with containers for a position and radius (for player or bots)
  function isPositionBlocked(pos, radius=0.5){
    const playerBox = new THREE.Box3(
      new THREE.Vector3(pos.x - radius, pos.y - 1, pos.z - radius),
      new THREE.Vector3(pos.x + radius, pos.y + 1, pos.z + radius)
    );
    for(const container of containers){
      const containerBox = new THREE.Box3().setFromObject(container);
      if(boxIntersect(playerBox, containerBox)) return true;
    }
    // Also block outside map boundary
    if(pos.x < -mapSize/2 || pos.x > mapSize/2 || pos.z < -mapSize/2 || pos.z > mapSize/2) return true;
    return false;
  }

  // Player respawn
  function respawnPlayer(){
    player.health = player.maxHealth;
    updateHUD();
    controls.getObject().position.set(0,2,0);
  }

  // Update HUD info
  function updateHUD(){
    healthEl.textContent = `Health: ${Math.floor(player.health)}`;
    bulletsEl.textContent = `Bullets: ${player.bulletsInClip} / ${player.maxBullets}`;
  }

  // Pause toggle
  function togglePause(){
    paused = !paused;
    if(paused){
      pauseMenu.style.display = 'flex';
      controls.unlock();
    } else {
      pauseMenu.style.display = 'none';
      controls.lock();
    }
  }

  resumeBtn.onclick = () => {
    togglePause();
  };

  // Main animation and logic loop
  function animate(){
    if(!paused){
      const delta = clock.getDelta();
      updatePlayerMovement(delta);
      updateBullets(delta);
      updateEnemyBullets(delta);
      updateBots(delta);
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Player movement + collision
  function updatePlayerMovement(delta){
    if(!controls.isLocked) return;

    const speed = player.speed * delta;
    const pos = controls.getObject().position.clone();

    let forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    let right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    let move = new THREE.Vector3();

    if(keys['KeyW']) move.add(forward);
    if(keys['KeyS']) move.sub(forward);
    if(keys['KeyA']) move.sub(right);
    if(keys['KeyD']) move.add(right);

    move.normalize();
    move.multiplyScalar(speed);

    let newPos = pos.clone().add(move);

    if(!isPositionBlocked(newPos)){
      controls.getObject().position.copy(newPos);
    }

    // Gravity & jumping
    velocityY += gravity * delta;
    let nextY = controls.getObject().position.y + velocityY;
    if(nextY < 2){ // floor level
      velocityY = 0;
      controls.getObject().position.y = 2;
      onGround = true;
    } else {
      controls.getObject().position.y = nextY;
      onGround = false;
    }
  }

  // Update player bullets
  function updateBullets(delta){
    for(let i = bullets.length - 1; i >= 0; i--){
      const b = bullets[i];
      b.position.addScaledVector(b.velocity, delta*60);
      // Remove bullets after distance or hitting containers or bots
      if(b.position.length() > 200){
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }
      // Check container collision
      if(isPositionBlocked(b.position, 0.1)){
        scene.remove(b);
        bullets.splice(i,1);
        continue;
      }
      // Check hit bots
      for(let bot of bots){
        if(bot.health <= 0) continue;
        if(bot.position.distanceTo(b.position) < 1){
          bot.health -= 25;
          scene.remove(b);
          bullets.splice(i,1);
          if(bot.health <= 0){
            // Remove bot and respawn after 5 sec
            setTimeout(() => {
              spawnBot(randomPos(), randomPos());
            }, 5000);
            scene.remove(bot);
            bots.splice(bots.indexOf(bot),1);
          }
          break;
        }
      }
    }
  }

  // Update enemy bullets
  function updateEnemyBullets(delta){
    for(let i = enemyBullets.length -1; i>=0; i--){
      const b = enemyBullets[i];
      b.position.addScaledVector(b.velocity, delta*60);

      if(b.position.distanceTo(controls.getObject().position) < 1){
        // Hit player
        player.health -= 10;
        updateHUD();
        scene.remove(b);
        enemyBullets.splice(i,1);
        if(player.health <= 0){
          respawnPlayer();
        }
        continue;
      }
      // Check container collision
      if(isPositionBlocked(b.position, 0.1)){
        scene.remove(b);
        enemyBullets.splice(i,1);
        continue;
      }
      // Remove if out of range
      if(b.position.length() > 200){
        scene.remove(b);
        enemyBullets.splice(i,1);
      }
    }
  }

  // Update bots logic
  function updateBots(delta){
    const playerPos = controls.getObject().position;

    for(let bot of bots){
      if(bot.health <= 0) continue;

      // Simple AI: move toward player
      const dir = new THREE.Vector3().subVectors(playerPos, bot.position);
      dir.y = 0;
      if(dir.length() > 2){
        dir.normalize();
        let newPos = bot.position.clone().addScaledVector(dir, delta*2);
        if(!isPositionBlocked(newPos)){
          bot.position.copy(newPos);
        }
      }

      // Random shooting with cooldown
      if(bot.reloadTimer > 0){
        bot.reloadTimer -= delta;
        if(bot.reloadTimer <= 0){
          bot.canShoot = true;
        }
      } else {
        if(bot.canShoot && dir.length() < 15){
          // 25% chance to shoot each frame
          if(Math.random() < 0.02){
            botShoot(bot);
          }
        }
      }
    }
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Start everything
  init();
  updateHUD();
  animate();
})();
</script>
</body>
</html>
