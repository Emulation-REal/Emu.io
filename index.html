<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emu.io - FPS with Bots</title>
<style>
  /* Reset & basics */
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #111;
    color: #eee;
    user-select: none;
  }

  /* Main menu container */
  #mainMenu {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(135deg, #222 0%, #111 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    z-index: 10;
  }

  #mainMenu h1 {
    font-size: 3em;
    letter-spacing: 4px;
    color: #4fc3f7;
    text-shadow: 0 0 10px #4fc3f7aa;
    margin-bottom: 40px;
  }

  .mapBtn {
    background: #222;
    color: #4fc3f7;
    border: 2px solid #4fc3f7;
    padding: 15px 40px;
    font-size: 1.2em;
    cursor: pointer;
    border-radius: 8px;
    transition: background 0.3s, color 0.3s;
  }
  .mapBtn:hover {
    background: #4fc3f7;
    color: #111;
  }

  /* Health bar container */
  #healthBarContainer {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 220px;
    height: 28px;
    background: #222;
    border: 2px solid #b71c1c;
    border-radius: 6px;
    display: none;
    z-index: 15;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #d32f2f, #b71c1c);
    border-radius: 4px;
    transition: width 0.3s;
  }
  #healthText {
    position: absolute;
    top: 2px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: 700;
    color: #fff;
    user-select: none;
    font-family: monospace;
  }

  /* Pause menu */
  #pauseMenu {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.85);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    z-index: 20;
    color: #eee;
  }
  #pauseMenu button {
    padding: 12px 30px;
    font-size: 1.1em;
    border-radius: 8px;
    border: 2px solid #4fc3f7;
    background: #222;
    color: #4fc3f7;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
  }
  #pauseMenu button:hover {
    background: #4fc3f7;
    color: #111;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>

<!-- Main Menu -->
<div id="mainMenu">
  <h1>Emu.io</h1>
  <button class="mapBtn" data-map="0">Map: Arena</button>
  <button class="mapBtn" data-map="1">Map: Maze</button>
  <button class="mapBtn" data-map="2">Map: Open Field</button>
</div>

<!-- Health Bar -->
<div id="healthBarContainer">
  <div id="healthBar"></div>
  <div id="healthText">100</div>
</div>

<!-- Pause Menu -->
<div id="pauseMenu">
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
  <button id="mainMenuBtn">Main Menu</button>
</div>

<!-- Three.js & PointerLockControls from official CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.min.js"></script>

<script>
(() => {
  // THREE.js essentials
  let scene, camera, renderer, controls;
  let player;
  let clock;
  let playerHealth = 100;
  const maxHealth = 100;

  // DOM elements
  const mainMenu = document.getElementById('mainMenu');
  const healthBarContainer = document.getElementById('healthBarContainer');
  const healthBar = document.getElementById('healthBar');
  const healthText = document.getElementById('healthText');
  const pauseMenu = document.getElementById('pauseMenu');

  // Game state
  let isPaused = false;
  let currentMapIndex = 0;

  // Movement & shooting
  const moveSpeed = 6;
  const bullets = [];
  const enemyBullets = [];

  // AI
  const enemies = [];

  // Audio context and sounds
  let audioContext;
  const sounds = {};

  // Setup Three.js scene
  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Player container object
    player = new THREE.Object3D();
    scene.add(player);

    // Add camera as a child of player for easy movement
    player.add(camera);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(0, 20, 10);
    scene.add(directionalLight);

    // Controls
    controls = new THREE.PointerLockControls(camera, document.body);

    controls.addEventListener('lock', () => {
      if(!isPaused) {
        healthBarContainer.style.display = 'block';
        mainMenu.style.display = 'none';
        pauseMenu.style.display = 'none';
      }
    });
    controls.addEventListener('unlock', () => {
      if(!isPaused) {
        pauseGame();
      }
    });

    // Setup audio
    initAudio();

    // Create the player hitbox or collision shape (for future expansion)
    player.userData = { canShoot: true, shootCooldown: 0 };

    // Setup clock
    clock = new THREE.Clock();

    // Input handling
    setupInput();

    // Start render loop
    animate();

    // Setup window resize
    window.addEventListener('resize', onWindowResize);
  }

  // Setup keyboard input
  const keys = {};
  function setupInput() {
    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      if(e.code === 'Escape') {
        if(isPaused) {
          resumeGame();
        } else {
          pauseGame();
        }
      }
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
    });

    // Mouse click to shoot
    window.addEventListener('mousedown', e => {
      if(controls.isLocked && !isPaused) shootBullet();
    });
  }

  // Window resize
  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Initialize audio and sounds
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      sounds.shoot = createBeep(1000, 0.05);
      sounds.hit = createBeep(400, 0.1);
      sounds.death = createBeep(200, 0.3);
      sounds.menuMusic = null; // Placeholder for future music
    } catch (e) {
      console.warn('Web Audio API not supported.');
    }
  }

  // Create a beep sound function
  function createBeep(freq, duration) {
    return function() {
      if(!audioContext) return;
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioContext.destination);
      osc.frequency.value = freq;
      osc.type = 'square';
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      osc.start();
      osc.stop(audioContext.currentTime + duration);
      osc.onended = () => {
        gainNode.disconnect();
        osc.disconnect();
      };
    };
  }

  // Play a sound by name
  function playSound(name) {
    if(sounds[name]) sounds[name]();
  }

  // Shoot a bullet from the player
  function shootBullet() {
    if(!player.userData.canShoot) return;
    // Cooldown ~0.3 sec between shots
    const now = performance.now();
    if(player.userData.lastShot && now - player.userData.lastShot < 300) return;

    player.userData.lastShot = now;

    // Create bullet geometry
    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
    const material = new THREE.MeshBasicMaterial({color: 0xffaa00});
    const bullet = new THREE.Mesh(geometry, material);

    // Position bullet at camera (player) position
    const bulletPos = new THREE.Vector3();
    camera.getWorldPosition(bulletPos);
    bullet.position.copy(bulletPos);

    // Direction bullet moves
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);

    bullets.push({mesh: bullet, direction, speed: 30});
    scene.add(bullet);

    playSound('shoot');
  }

  // Shoot bullet from enemy
  function enemyShoot(enemy) {
    if(!enemy.canShoot) return;

    const now = performance.now();
    if(enemy.lastShot && now - enemy.lastShot < 700 + Math.random()*700) return; // random slower fire rate

    enemy.lastShot = now;

    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
    const material = new THREE.MeshBasicMaterial({color: 0xff4444});
    const bullet = new THREE.Mesh(geometry, material);

    bullet.position.copy(enemy.mesh.position);
    const direction = new THREE.Vector3();
    // Shoot roughly towards player, with slight randomness
    direction.subVectors(player.position, enemy.mesh.position).normalize();
    direction.x += (Math.random() - 0.5) * 0.2;
    direction.z += (Math.random() - 0.5) * 0.2;
    direction.normalize();

    enemyBullets.push({mesh: bullet, direction, speed: 20});
    scene.add(bullet);

    playSound('shoot');
  }

  // Update bullets positions and collisions
  function updateBullets(delta) {
    // Player bullets
    for(let i=bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.mesh.position.addScaledVector(b.direction, b.speed * delta);

      // Remove bullet if too far
      if(b.mesh.position.distanceTo(player.position) > 100) {
        scene.remove(b.mesh);
        bullets.splice(i, 1);
        continue;
      }

      // Check collision with enemies
      for(let enemy of enemies) {
        if(enemy.health <= 0) continue;
        if(b.mesh.position.distanceTo(enemy.mesh.position) < 0.7) {
          // Hit enemy
          enemy.health -= 25;
          playSound('hit');
          scene.remove(b.mesh);
          bullets.splice(i, 1);

          if(enemy.health <= 0) {
            playSound('death');
            scene.remove(enemy.mesh);
          }
          break;
        }
      }
    }

    // Enemy bullets
    for(let i=enemyBullets.length-1; i>=0; i--) {
      const b = enemyBullets[i];
      b.mesh.position.addScaledVector(b.direction, b.speed * delta);

      if(b.mesh.position.distanceTo(player.position) > 100) {
        scene.remove(b.mesh);
        enemyBullets.splice(i, 1);
        continue;
      }

      // Check collision with player
      if(b.mesh.position.distanceTo(player.position) < 0.7) {
        playerHealth -= 10;
        updateHealthUI();
        playSound('hit');
        scene.remove(b.mesh);
        enemyBullets.splice(i, 1);

        if(playerHealth <= 0) {
          playSound('death');
          respawnPlayer();
        }
        break;
      }
    }
  }

  // Update enemies AI
  function updateEnemies(delta) {
    for(let enemy of enemies) {
      if(enemy.health <= 0) continue;

      // Move toward player on XZ plane
      const enemyPos = enemy.mesh.position;
      const playerPos = player.position;
      const dir = new THREE.Vector3();
      dir.subVectors(playerPos, enemyPos);
      dir.y = 0;
      if(dir.length() > 1) {
        dir.normalize();
        enemy.mesh.position.addScaledVector(dir, enemy.speed * delta);
      }

      // Enemy shoots randomly
      if(Math.random() < 0.005) {
        enemyShoot(enemy);
      }
    }
  }

  // Update player movement based on keys
  function updatePlayerMovement(delta) {
    if(!controls.isLocked || isPaused) return;

    const velocity = new THREE.Vector3();
    if(keys['KeyW']) velocity.z -= 1;
    if(keys['KeyS']) velocity.z += 1;
    if(keys['KeyA']) velocity.x -= 1;
    if(keys['KeyD']) velocity.x += 1;

    if(velocity.length() > 0) {
      velocity.normalize();
      // Move relative to camera rotation on Y axis
      const angle = camera.rotation.y;
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      const moveX = velocity.x * cos - velocity.z * sin;
      const moveZ = velocity.z * cos + velocity.x * sin;

      player.position.x += moveX * moveSpeed * delta;
      player.position.z += moveZ * moveSpeed * delta;
    }
  }

  // Update health bar UI
  function updateHealthUI() {
    const pct = Math.max(0, Math.min(1, playerHealth / maxHealth));
    healthBar.style.width = (pct * 100) + '%';
    healthText.textContent = Math.round(playerHealth);
  }

  // Respawn player after death
  function respawnPlayer() {
    playerHealth = maxHealth;
    player.position.set(0, 1.6, 0);
    updateHealthUI();
  }

  // Clear current map and enemies
  function clearMap() {
    // Remove enemies
    for(let enemy of enemies) {
      scene.remove(enemy.mesh);
    }
    enemies.length = 0;

    // Remove bullets
    for(let b of bullets) scene.remove(b.mesh);
    bullets.length = 0;
    for(let b of enemyBullets) scene.remove(b.mesh);
    enemyBullets.length = 0;

    // Remove all objects except player and camera (which is child of player)
    while(scene.children.length > 2) {
      const obj = scene.children.find(o => o !== player && o !== camera);
      if(!obj) break;
      scene.remove(obj);
    }
  }

  // Create an enemy and add to scene
  function createEnemy(x, z) {
    const geometry = new THREE.BoxGeometry(1, 2, 1);
    const material = new THREE.MeshStandardMaterial({color: 0x333333});
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, 1, z);
    scene.add(mesh);
    enemies.push({
      mesh,
      health: 100,
      speed: 2,
      canShoot: true,
      lastShot: 0
    });
  }

  // Create the map layouts
  const maps = [
    // Map 0 - Arena (simple open box)
    () => {
      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(30, 30),
        new THREE.MeshStandardMaterial({color: 0x222222})
      );
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Walls - simple box walls
      const wallMat = new THREE.MeshStandardMaterial({color: 0x444444});
      const wallGeom = new THREE.BoxGeometry(30, 5, 1);

      const walls = [];

      // Back wall
      const backWall = new THREE.Mesh(wallGeom, wallMat);
      backWall.position.set(0, 2.5, -15);
      walls.push(backWall);

      // Front wall
      const frontWall = new THREE.Mesh(wallGeom, wallMat);
      frontWall.position.set(0, 2.5, 15);
      walls.push(frontWall);

      // Left wall
      const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 30), wallMat);
      leftWall.position.set(-15, 2.5, 0);
      walls.push(leftWall);

      // Right wall
      const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 5, 30), wallMat);
      rightWall.position.set(15, 2.5, 0);
      walls.push(rightWall);

      for(let w of walls) scene.add(w);

      // Spawn enemies around arena
      createEnemy(5, 5);
      createEnemy(-5, 5);
      createEnemy(5, -5);
      createEnemy(-5, -5);
    },
    // Map 1 - Maze (simple grid maze with walls)
    () => {
      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshStandardMaterial({color: 0x111111})
      );
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Walls
      const wallMat = new THREE.MeshStandardMaterial({color: 0x666666});
      const wallGeom = new THREE.BoxGeometry(2, 4, 2);

      // Maze walls positions
      const mazeWalls = [
        [-6, 1], [-2, 1], [2, 1], [6, 1],
        [-6, -1], [-2, -1], [2, -1], [6, -1],
        [-6, -5], [-2, -5], [2, -5], [6, -5],
        [-10, 3], [10, 3], [-10, -3], [10, -3],
        [0, 7], [0, -7],
      ];

      for(const pos of mazeWalls) {
        const wall = new THREE.Mesh(wallGeom, wallMat);
        wall.position.set(pos[0], 2, pos[1]);
        scene.add(wall);
      }

      // Spawn enemies inside maze
      createEnemy(0, 0);
      createEnemy(-8, 4);
      createEnemy(8, -4);
    },
    // Map 2 - Open field with scattered obstacles
    () => {
      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({color: 0x114411})
      );
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // Trees or rocks (simple cylinders/cones)
      for(let i=0; i<10; i++) {
        const tree = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 5),
          new THREE.MeshStandardMaterial({color: 0x442200})
        );
        tree.position.set(
          (Math.random() - 0.5) * 40,
          2.5,
          (Math.random() - 0.5) * 40
        );
        scene.add(tree);

        const leaves = new THREE.Mesh(
          new THREE.ConeGeometry(2, 4, 8),
          new THREE.MeshStandardMaterial({color: 0x228822})
        );
        leaves.position.set(tree.position.x, 6, tree.position.z);
        scene.add(leaves);
      }

      // Spawn enemies scattered
      for(let i=0; i<5; i++) {
        createEnemy(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 40
        );
      }
    }
  ];

  // Start game with selected map
  function startGame(mapIndex) {
    currentMapIndex = mapIndex;

    clearMap();

    respawnPlayer();
    player.position.set(0, 1.6, 0);

    // Setup map
    maps[mapIndex]();

    // Lock pointer for FPS controls
    controls.lock();

    healthBarContainer.style.display = 'block';
    pauseMenu.style.display = 'none';
    mainMenu.style.display = 'none';
    isPaused = false;
  }

  // Pause & resume
  function pauseGame() {
    isPaused = true;
    controls.unlock();
    pauseMenu.style.display = 'flex';
    healthBarContainer.style.display = 'none';
  }

  function resumeGame() {
    isPaused = false;
    pauseMenu.style.display = 'none';
    healthBarContainer.style.display = 'block';
    controls.lock();
  }

  // Main animation loop
  function animate() {
    requestAnimationFrame(animate);
    if(!isPaused) {
      const delta = clock.getDelta();

      updatePlayerMovement(delta);
      updateEnemies(delta);
      updateBullets(delta);
    }
    renderer.render(scene, camera);
  }

  // Setup buttons on main menu and pause menu
  function setupUI() {
    // Map buttons
    const buttons = document.querySelectorAll('.mapBtn');
    buttons.forEach(btn => {
      btn.onclick = () => {
        const mapIdx = Number(btn.dataset.map);
        startGame(mapIdx);
      };
    });

    // Pause menu buttons
    document.getElementById('resumeBtn').onclick = resumeGame;
    document.getElementById('mainMenuBtn').onclick = () => {
      pauseMenu.style.display = 'none';
      healthBarContainer.style.display = 'none';
      mainMenu.style.display = 'flex';
      clearMap();
      isPaused = true;
      controls.unlock();
    };
  }

  // Initialize UI and Three.js
  setupUI();
  init();

  updateHealthUI();

})();
</script>

</body>
</html>
