<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Shooter Prototype</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #111;
    color: white;
    user-select: none;
  }
  #mainMenu, #pauseMenu {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(8px);
    background: rgba(20,20,20,0.75);
    z-index: 10;
  }
  #mainMenu {
    z-index: 20;
  }
  #mainMenu h1 {
    font-size: 3rem;
    margin-bottom: 50px;
    text-shadow: 0 0 12px #fff;
  }
  #playBtn, #resumeBtn {
    padding: 15px 50px;
    font-size: 1.5rem;
    cursor: pointer;
    border: 2px solid #ccc;
    border-radius: 10px;
    background: #444;
    color: white;
    box-shadow: inset 0 0 10px #222;
    transition: all 0.3s ease;
  }
  #playBtn:hover, #resumeBtn:hover {
    background: #555;
    border-color: #eee;
    box-shadow: 0 0 15px #aaa;
  }
  #hud {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 1.1rem;
    color: #eee;
    z-index: 15;
    text-shadow: 0 0 6px #000;
    user-select: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #222;
  }
</style>
</head>
<body>

<div id="mainMenu">
  <h1>3D Shooter Prototype</h1>
  <button id="playBtn">Play</button>
</div>

<div id="pauseMenu" style="display:none;">
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
</div>

<div id="hud" style="display:none;">
  Ammo: <span id="ammoCount">30</span> / <span id="magSize">30</span><br/>
  Reloading: <span id="reloadingStatus">No</span><br/>
  Enemies Alive: <span id="enemyCount">0</span><br/>
  Health: <span id="healthCount">100</span><br/>
  <small>WASD = move, Mouse = look, Left Click = shoot, R = reload, P = pause</small>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);

  // Scene, Camera, Renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(5,10,7);
  scene.add(directionalLight);

  // Floor
  const floorGeometry = new THREE.PlaneGeometry(100, 100);
  const floorMaterial = new THREE.MeshStandardMaterial({color: 0x555555});
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Player
  let player = {
    health: 100,
    ammo: 30,
    magSize: 30,
    reloading: false,
    reloadTime: 2000,
    canShoot: true,
  };

  // Controls
  const controls = new THREE.PointerLockControls(camera, document.body);

  // Setup player initial position
  camera.position.set(0, 1.6, 5);

  // Movement vars
  const movement = {
    forward: false,
    backward: false,
    left: false,
    right: false,
  };
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();

  // Enemies
  const enemies = [];
  const enemyCount = 5;
  const enemySpeed = 1.0;
  const enemySize = 0.7;

  // Bullets
  const bullets = [];

  // HTML Elements
  const mainMenu = document.getElementById('mainMenu');
  const playBtn = document.getElementById('playBtn');
  const pauseMenu = document.getElementById('pauseMenu');
  const resumeBtn = document.getElementById('resumeBtn');
  const hud = document.getElementById('hud');
  const ammoCountEl = document.getElementById('ammoCount');
  const magSizeEl = document.getElementById('magSize');
  const reloadingStatusEl = document.getElementById('reloadingStatus');
  const enemyCountEl = document.getElementById('enemyCount');
  const healthCountEl = document.getElementById('healthCount');

  let gameRunning = false;
  let gamePaused = false;

  // Utility - create enemy mesh
  function createEnemy() {
    const geometry = new THREE.BoxGeometry(enemySize, enemySize * 2, enemySize);
    const material = new THREE.MeshStandardMaterial({color: 0xff4444});
    const enemy = new THREE.Mesh(geometry, material);

    enemy.position.set(
      (Math.random() - 0.5) * 40,
      enemySize,
      (Math.random() - 0.5) * 40
    );

    enemy.health = 50;
    enemy.alive = true;
    enemy.lastShot = 0;

    scene.add(enemy);
    return enemy;
  }

  // Spawn enemies
  function spawnEnemies() {
    for(let i = 0; i < enemyCount; i++) {
      enemies.push(createEnemy());
    }
    enemyCountEl.textContent = enemies.length;
  }

  // Remove dead enemy and respawn after delay
  function respawnEnemy(enemy) {
    enemy.alive = false;
    scene.remove(enemy);
    setTimeout(() => {
      const newEnemy = createEnemy();
      const idx = enemies.indexOf(enemy);
      if (idx !== -1) enemies[idx] = newEnemy;
      enemyCountEl.textContent = enemies.filter(e => e.alive).length;
    }, 5000);
  }

  // Shoot bullet from position towards direction
  function shootBullet(position, direction, owner) {
    const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({color: owner === 'player' ? 0x00aaff : 0xff4400});
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

    bullet.position.copy(position);
    bullet.velocity = direction.clone().multiplyScalar(20);
    bullet.owner = owner;

    scene.add(bullet);
    bullets.push(bullet);
  }

  // Handle shooting from player
  function playerShoot() {
    if (player.reloading || !player.canShoot || player.ammo <= 0) return;
    player.ammo--;
    ammoCountEl.textContent = player.ammo;
    player.canShoot = false;

    // Shoot bullet from camera position in camera direction
    const origin = new THREE.Vector3();
    origin.copy(camera.position);
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);

    shootBullet(origin, dir, 'player');

    // Fire rate cooldown
    setTimeout(() => {
      player.canShoot = true;
    }, 250);
  }

  // Player reload
  function playerReload() {
    if (player.reloading || player.ammo === player.magSize) return;
    player.reloading = true;
    reloadingStatusEl.textContent = 'Yes';
    setTimeout(() => {
      player.ammo = player.magSize;
      ammoCountEl.textContent = player.ammo;
      player.reloading = false;
      reloadingStatusEl.textContent = 'No';
    }, player.reloadTime);
  }

  // Check bullet collisions
  function checkBulletCollisions(delta) {
    for(let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.position.addScaledVector(b.velocity, delta);

      // Remove bullet if out of bounds
      if (b.position.length() > 100) {
        scene.remove(b);
        bullets.splice(i, 1);
        continue;
      }

      if (b.owner === 'player') {
        // Check against enemies
        for(const enemy of enemies) {
          if (!enemy.alive) continue;
          if (b.position.distanceTo(enemy.position) < enemySize) {
            // Hit enemy
            enemy.health -= 25;
            if (enemy.health <= 0) {
              respawnEnemy(enemy);
            }
            scene.remove(b);
            bullets.splice(i, 1);
            break;
          }
        }
      } else if (b.owner === 'enemy') {
        // Check against player - approximate as sphere around camera
        const playerPos = camera.position;
        if (b.position.distanceTo(playerPos) < 1) {
          player.health -= 10;
          if (player.health < 0) player.health = 0;
          scene.remove(b);
          bullets.splice(i, 1);
          break;
        }
      }
    }
  }

  // Update enemies movement & shooting
  function updateEnemies(delta) {
    for(const enemy of enemies) {
      if (!enemy.alive) continue;

      // Move toward player
      const directionToPlayer = new THREE.Vector3();
      directionToPlayer.subVectors(camera.position, enemy.position);
      directionToPlayer.y = 0; // No vertical movement
      const distance = directionToPlayer.length();
      directionToPlayer.normalize();

      if (distance > 1.5) {
        enemy.position.addScaledVector(directionToPlayer, enemySpeed * delta);
      }

      // Rotate enemy to face player
      enemy.lookAt(camera.position.x, enemy.position.y, camera.position.z);

      // Enemy shooting cooldown
      if (Date.now() - enemy.lastShot > 1500) {
        // Shoot towards player
        const bulletDir = new THREE.Vector3();
        bulletDir.subVectors(camera.position, enemy.position).normalize();
        const bulletOrigin = enemy.position.clone();
        bulletOrigin.y += enemySize; // shoot from enemy head level
        shootBullet(bulletOrigin, bulletDir, 'enemy');
        enemy.lastShot = Date.now();
      }
    }
  }

  // Handle player movement update
  function updatePlayerMovement(delta) {
    if (!controls.isLocked) return;

    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    direction.z = Number(movement.forward) - Number(movement.backward);
    direction.x = Number(movement.right) - Number(movement.left);
    direction.normalize();

    if (movement.forward || movement.backward) velocity.z -= direction.z * 400.0 * delta;
    if (movement.left || movement.right) velocity.x -= direction.x * 400.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);
  }

  // Resize handler
  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onWindowResize);

  // Keyboard handlers
  function onKeyDown(event) {
    if(event.code === 'KeyW') movement.forward = true;
    if(event.code === 'KeyS') movement.backward = true;
    if(event.code === 'KeyA') movement.left = true;
    if(event.code === 'KeyD') movement.right = true;
    if(event.code === 'KeyR') playerReload();
    if(event.code === 'KeyP') togglePause();
    if(event.code === 'Escape') {
      if(gamePaused) togglePause();
      else controls.unlock();
    }
  }
  function onKeyUp(event) {
    if(event.code === 'KeyW') movement.forward = false;
    if(event.code === 'KeyS') movement.backward = false;
    if(event.code === 'KeyA') movement.left = false;
    if(event.code === 'KeyD') movement.right = false;
  }
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);

  // Mouse click to shoot
  window.addEventListener('mousedown', (e) => {
    if (gameRunning && !gamePaused && e.button === 0) {
      playerShoot();
    }
  });

  // Game loop
  let prevTime = performance.now();
  function animate(time) {
    requestAnimationFrame(animate);
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    if(gameRunning && !gamePaused) {
      updatePlayerMovement(delta);
      updateEnemies(delta);
      checkBulletCollisions(delta);
    }

    healthCountEl.textContent = Math.floor(player.health);
    enemyCountEl.textContent = enemies.filter(e => e.alive).length;

    renderer.render(scene, camera);
  }

  // Pause toggle
  function togglePause() {
    if(!gameRunning) return;
    gamePaused = !gamePaused;
    pauseMenu.style.display = gamePaused ? 'flex' : 'none';
    hud.style.display = gamePaused ? 'none' : 'block';
    if(gamePaused) controls.unlock();
    else controls.lock();
  }

  // Start game
  playBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    hud.style.display = 'block';
    gameRunning = true;

    controls.lock();
    spawnEnemies();
    animate(performance.now());
  });

  // Resume button
  resumeBtn.addEventListener('click', () => {
    togglePause();
  });

  // Lock controls events
  controls.addEventListener('lock', () => {
    pauseMenu.style.display = 'none';
    hud.style.display = 'block';
    gamePaused = false;
  });
  controls.addEventListener('unlock', () => {
    if(gameRunning) {
      pauseMenu.style.display = 'flex';
      hud.style.display = 'none';
      gamePaused = true;
    }
  });

})();
</script>
</body>
</html>
