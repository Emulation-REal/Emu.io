<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shooter Game with AI, Maps, Menus, Respawn</title>
<style>
  /* Reset & basic styling */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #222;
    color: #eee;
    overflow: hidden;
  }
  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
    border: 1px solid #555;
  }

  /* Main menu styling */
  #main-menu, #pause-menu {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #2c2c2c;
    padding: 30px 40px;
    border-radius: 8px;
    box-shadow: 0 0 15px rgba(0,0,0,0.7);
    text-align: center;
    width: 320px;
    display: none;
  }
  #main-menu.active, #pause-menu.active {
    display: block;
  }
  h1 {
    margin-bottom: 20px;
    font-weight: 700;
    font-size: 28px;
  }
  button {
    background: #444;
    border: none;
    padding: 12px 18px;
    margin: 10px 0;
    width: 100%;
    color: #eee;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.25s;
  }
  button:hover {
    background: #666;
  }

  /* Info text */
  #info {
    position: absolute;
    top: 8px; left: 50%;
    transform: translateX(-50%);
    font-size: 14px;
    color: #ccc;
    user-select: none;
  }

</style>
</head>
<body>

<!-- Canvas for game -->
<canvas id="gameCanvas" width="800" height="450"></canvas>

<!-- Main Menu -->
<div id="main-menu" class="active">
  <h1>Select a Map</h1>
  <button data-map="0">Map 1: Open Field</button>
  <button data-map="1">Map 2: Maze</button>
  <button data-map="2">Map 3: Platforms</button>
</div>

<!-- Pause Menu -->
<div id="pause-menu">
  <h1>Paused</h1>
  <button id="resume-btn">Resume</button>
  <button id="back-main-btn">Back to Main Menu</button>
</div>

<!-- Info -->
<div id="info">Use WASD to move, mouse to aim and shoot</div>

<script>
// Get elements
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mainMenu = document.getElementById('main-menu');
const pauseMenu = document.getElementById('pause-menu');
const resumeBtn = document.getElementById('resume-btn');
const backMainBtn = document.getElementById('back-main-btn');
const mapButtons = mainMenu.querySelectorAll('button[data-map]');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

let gameState = 'menu'; // 'menu', 'playing', 'paused'

/* ===== Game Variables ===== */
let keys = {};
let mouse = { x: 0, y: 0, down: false };

const PLAYER_SIZE = 20;
const PLAYER_SPEED = 3;

const BULLET_SPEED = 8;
const ENEMY_BULLET_SPEED = 4;
const ENEMY_SPEED = 1.5;
const ENEMY_SHOOT_INTERVAL_MIN = 1200; // min ms between enemy shots
const ENEMY_SHOOT_INTERVAL_MAX = 3000; // max ms between enemy shots

// Maps (each map defines walls/platforms)
const maps = [
  {
    name: "Open Field",
    walls: []
  },
  {
    name: "Maze",
    walls: [
      {x: 100, y: 50, w: 600, h: 20},
      {x: 100, y: 380, w: 600, h: 20},
      {x: 100, y: 50, w: 20, h: 350},
      {x: 680, y: 50, w: 20, h: 350},
      // inner walls for maze
      {x: 200, y: 120, w: 20, h: 250},
      {x: 300, y: 50, w: 20, h: 250},
      {x: 400, y: 150, w: 20, h: 250},
      {x: 500, y: 50, w: 20, h: 250},
      {x: 600, y: 150, w: 20, h: 250},
    ]
  },
  {
    name: "Platforms",
    walls: [
      {x: 0, y: 400, w: 800, h: 20},
      {x: 100, y: 320, w: 150, h: 20},
      {x: 300, y: 240, w: 150, h: 20},
      {x: 550, y: 300, w: 150, h: 20},
      {x: 200, y: 150, w: 150, h: 20},
    ]
  }
];

// Game objects
let player, enemies, bullets, enemyBullets, currentMap;

function createPlayer() {
  return {
    x: WIDTH / 2,
    y: HEIGHT - 50,
    w: PLAYER_SIZE,
    h: PLAYER_SIZE,
    speed: PLAYER_SPEED,
    alive: true,
    respawnCooldown: 0
  };
}

function createEnemy(x, y) {
  return {
    x, y,
    w: PLAYER_SIZE,
    h: PLAYER_SIZE,
    speed: ENEMY_SPEED,
    lastShootTime: 0,
    nextShootDelay: randomRange(ENEMY_SHOOT_INTERVAL_MIN, ENEMY_SHOOT_INTERVAL_MAX)
  };
}

function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

function rectsCollide(a, b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

// Initialize game with chosen map
function startGame(mapIndex) {
  currentMap = maps[mapIndex];
  player = createPlayer();
  enemies = [];

  // Spawn enemies depending on map
  if(mapIndex === 0) {
    enemies.push(createEnemy(100, 100));
    enemies.push(createEnemy(700, 100));
  } else if(mapIndex === 1) {
    enemies.push(createEnemy(150, 100));
    enemies.push(createEnemy(650, 300));
    enemies.push(createEnemy(400, 200));
  } else if(mapIndex === 2) {
    enemies.push(createEnemy(150, 270));
    enemies.push(createEnemy(400, 190));
    enemies.push(createEnemy(600, 260));
  }

  bullets = [];
  enemyBullets = [];
  gameState = 'playing';

  mainMenu.classList.remove('active');
  pauseMenu.classList.remove('active');

  // Reset input states
  keys = {};
  mouse.down = false;
}

// Handle player movement with WASD and collision with walls
function movePlayer() {
  if (!player.alive) return;

  let dx = 0, dy = 0;
  if (keys['KeyW']) dy -= player.speed;
  if (keys['KeyS']) dy += player.speed;
  if (keys['KeyA']) dx -= player.speed;
  if (keys['KeyD']) dx += player.speed;

  // Move and collide with walls
  tryMove(player, dx, dy);
}

// Try move entity and collide with walls
function tryMove(entity, dx, dy) {
  if (dx === 0 && dy === 0) return;

  // Move X then check collisions
  entity.x += dx;
  if (collidesWithWalls(entity)) {
    entity.x -= dx;
  }
  // Move Y then check collisions
  entity.y += dy;
  if (collidesWithWalls(entity)) {
    entity.y -= dy;
  }

  // Keep inside canvas
  entity.x = Math.min(Math.max(0, entity.x), WIDTH - entity.w);
  entity.y = Math.min(Math.max(0, entity.y), HEIGHT - entity.h);
}

function collidesWithWalls(entity) {
  return currentMap.walls.some(wall => rectsCollide(entity, wall));
}

// Create a bullet object
function createBullet(x, y, vx, vy, fromEnemy = false) {
  return { x, y, vx, vy, w: 6, h: 6, fromEnemy };
}

// Update bullets position and remove off-screen
function updateBullets() {
  bullets = bullets.filter(b => {
    b.x += b.vx;
    b.y += b.vy;

    // Remove if out of screen
    if (b.x < -10 || b.x > WIDTH + 10 || b.y < -10 || b.y > HEIGHT + 10) return false;

    // Check collision with enemies (if from player)
    if (!b.fromEnemy) {
      for (let i = 0; i < enemies.length; i++) {
        if (rectsCollide(b, enemies[i])) {
          enemies.splice(i, 1);
          return false;
        }
      }
    } else {
      // If from enemy, check collision with player
      if (player.alive && rectsCollide(b, player)) {
        player.alive = false;
        player.respawnCooldown = 120; // frames to wait before respawn (~2 seconds at 60fps)
        return false;
      }
    }
    return true;
  });

  enemyBullets = enemyBullets.filter(b => {
    b.x += b.vx;
    b.y += b.vy;

    // Remove if out of screen
    if (b.x < -10 || b.x > WIDTH + 10 || b.y < -10 || b.y > HEIGHT + 10) return false;

    // Enemy bullets handled in bullets array already (to avoid duplication)
    return true;
  });
}

// Update enemies (move towards player slowly, and shoot randomly with delay)
function updateEnemies() {
  enemies.forEach(enemy => {
    // Move toward player (basic)
    let dx = player.x - enemy.x;
    let dy = player.y - enemy.y;
    let dist = Math.hypot(dx, dy);
    if (dist > 0) {
      let vx = (dx / dist) * enemy.speed;
      let vy = (dy / dist) * enemy.speed;

      tryMove(enemy, vx, vy);
    }

    // Shoot randomly based on time
    enemy.lastShootTime += 16.67; // approx frame time in ms

    if (enemy.lastShootTime >= enemy.nextShootDelay) {
      enemy.lastShootTime = 0;
      enemy.nextShootDelay = randomRange(ENEMY_SHOOT_INTERVAL_MIN, ENEMY_SHOOT_INTERVAL_MAX);

      // Shoot toward player with some randomness in direction
      let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      let spread = (Math.random() - 0.5) * 0.4; // +/- 0.2 radians randomness
      let vx = Math.cos(angle + spread) * ENEMY_BULLET_SPEED;
      let vy = Math.sin(angle + spread) * ENEMY_BULLET_SPEED;
      bullets.push(createBullet(enemy.x + enemy.w / 2, enemy.y + enemy.h / 2, vx, vy, true));
    }
  });
}

// Player shooting
function playerShoot() {
  if (!player.alive) return;
  if (!mouse.down) return;

  // Limit fire rate
  if (!player.lastShootTime) player.lastShootTime = 0;
  player.lastShootTime += 16.67;

  if (player.lastShootTime >= 200) { // 200ms between shots
    player.lastShootTime = 0;

    let angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    let vx = Math.cos(angle) * BULLET_SPEED;
    let vy = Math.sin(angle) * BULLET_SPEED;

    bullets.push(createBullet(player.x + player.w / 2, player.y + player.h / 2, vx, vy));
  }
}

// Respawn logic
function handleRespawn() {
  if (!player.alive) {
    player.respawnCooldown--;
    if (player.respawnCooldown <= 0) {
      player.x = WIDTH / 2;
      player.y = HEIGHT - 50;
      player.alive = true;
      player.respawnCooldown = 0;
    }
  }
}

// Draw functions
function drawRect(obj, color) {
  ctx.fillStyle = color;
  ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
}

function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  // Draw walls
  ctx.fillStyle = '#555';
  currentMap.walls.forEach(wall => {
    ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
  });

  // Draw player
  if (player.alive) {
    drawRect(player, '#4CAF50');
  } else {
    // Draw respawn timer
    ctx.fillStyle = '#ff4444';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Respawning...', WIDTH / 2, HEIGHT / 2);
  }

  // Draw enemies
  enemies.forEach(e => drawRect(e, '#e53935'));

  // Draw bullets
  bullets.forEach(b => drawRect(b, b.fromEnemy ? '#ff5722' : '#03A9F4'));
}

// Game Loop
function gameLoop() {
  if (gameState === 'playing') {
    movePlayer();
    playerShoot();
    updateBullets();
    updateEnemies();
    handleRespawn();
  }
  draw();
  requestAnimationFrame(gameLoop);
}

// Input handlers
window.addEventListener('keydown', e => {
  if (gameState === 'playing') {
    keys[e.code] = true;
    if (e.code === 'Escape') {
      pauseGame();
    }
  } else if (gameState === 'paused') {
    if (e.code === 'Escape') {
      resumeGame();
    }
  }
});
window.addEventListener('keyup', e => {
  keys[e.code] = false;
});
canvas.addEventListener('mousedown', e => {
  mouse.down = true;
});
canvas.addEventListener('mouseup', e => {
  mouse.down = false;
});
canvas.addEventListener('mousemove', e => {
  // Get mouse position relative to canvas
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});

// Pause & Resume
function pauseGame() {
  if (gameState !== 'playing') return;
  gameState = 'paused';
  pauseMenu.classList.add('active');
}
function resumeGame() {
  if (gameState !== 'paused') return;
  gameState = 'playing';
  pauseMenu.classList.remove('active');
}

// Back to main menu
backMainBtn.onclick = () => {
  gameState = 'menu';
  mainMenu.classList.add('active');
  pauseMenu.classList.remove('active');
};

// Resume button
resumeBtn.onclick = () => {
  resumeGame();
};

// Main menu map selection buttons
mapButtons.forEach(btn => {
  btn.onclick = () => {
    let mapIndex = Number(btn.getAttribute('data-map'));
    startGame(mapIndex);
  };
});

// Start with main menu visible
mainMenu.classList.add('active');
pauseMenu.classList.remove('active');

gameLoop();

</script>

</body>
</html>
