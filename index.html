<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D FPS Airsoft Field Demo</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%; background-color: #222;
    font-family: Arial, sans-serif;
    color: white;
  }
  #healthDisplay {
    position: absolute;
    top: 10px; left: 10px;
    background: rgba(0,0,0,0.6);
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 18px;
    z-index: 10;
  }
  #enterHint {
    position: absolute;
    bottom: 40px; width: 100%;
    text-align: center;
    font-size: 20px;
    color: #0ff;
    text-shadow: 0 0 6px #0ff;
    user-select: none;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="healthDisplay">Health: <span id="health">100</span></div>
<div id="enterHint"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // Setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(50, 100, 50);
  scene.add(directionalLight);

  // Controls and camera setup
  const controls = new THREE.PointerLockControls(camera, document.body);

  document.body.addEventListener('click', () => {
    controls.lock();
  });

  scene.add(controls.getObject());

  // Floor
  const floorGeo = new THREE.PlaneGeometry(300, 300);
  const floorMat = new THREE.MeshStandardMaterial({color:0x555533});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // Player data
  const player = {
    height: 1.8,
    speed: 12,
    jumpSpeed: 7,
    velocityY: 0,
    health: 100,
    isInsideHouse: false,
    currentHouse: null
  };

  camera.position.set(0, player.height, 0);
  controls.getObject().position.set(0, player.height, 0);

  // Houses
  const houses = [];
  function createHouse(x, z) {
    const house = new THREE.Group();

    const wallMat = new THREE.MeshStandardMaterial({color: 0x775533});
    const floorMat = new THREE.MeshStandardMaterial({color: 0x443311});
    const wallGeo = new THREE.BoxGeometry(6, 4, 6);
    const walls = new THREE.Mesh(wallGeo, wallMat);
    walls.position.y = 2;
    house.add(walls);

    const floorGeo = new THREE.PlaneGeometry(6, 6);
    const floorMesh = new THREE.Mesh(floorGeo, floorMat);
    floorMesh.rotation.x = -Math.PI/2;
    floorMesh.position.y = 0.01;
    house.add(floorMesh);

    house.position.set(x, 0, z);
    house.userData.collider = new THREE.Box3().setFromObject(walls);
    scene.add(house);
    houses.push(house);
  }

  createHouse(20, 20);
  createHouse(-40, 15);
  createHouse(30, -40);
  createHouse(-35, -35);

  // Containers (obstacles)
  const containers = [];
  function createContainer(x, z) {
    const geo = new THREE.BoxGeometry(8, 4, 4);
    const mat = new THREE.MeshStandardMaterial({color: 0x0077aa});
    const container = new THREE.Mesh(geo, mat);
    container.position.set(x, 2, z);
    scene.add(container);
    container.userData.collider = new THREE.Box3().setFromObject(container);
    containers.push(container);
  }

  // Scatter containers with gaps
  for(let x = -90; x <= 90; x += 20) {
    for(let z = -90; z <= 90; z += 15) {
      if(Math.random() < 0.65) {
        createContainer(x, z);
      }
    }
  }

  // Player collision box helper
  function playerCollides(pos) {
    const playerBox = new THREE.Box3(
      new THREE.Vector3(pos.x - 0.4, pos.y - 0.1, pos.z - 0.4),
      new THREE.Vector3(pos.x + 0.4, pos.y + player.height, pos.z + 0.4)
    );

    for(const c of containers) {
      if(playerBox.intersectsBox(c.userData.collider)) return true;
    }
    for(const h of houses) {
      const box = h.userData.collider.clone();
      box.expandByScalar(0.1);
      if(playerBox.intersectsBox(box)) {
        if(!player.isInsideHouse || player.currentHouse !== h) return true;
      }
    }
    return false;
  }

  // Enemies
  const enemies = [];
  function createEnemy(x, z) {
    const enemy = new THREE.Group();

    const bodyGeo = new THREE.BoxGeometry(0.6, 1.8, 0.4);
    const bodyMat = new THREE.MeshStandardMaterial({color: 0x882222});
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    enemy.add(body);

    const gunGeo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
    const gunMat = new THREE.MeshStandardMaterial({color: 0x333333});
    const gun = new THREE.Mesh(gunGeo, gunMat);
    gun.position.set(0, 1.2, 0.5);
    enemy.add(gun);

    enemy.position.set(x, 0, z);
    enemy.userData.health = 100;
    enemy.userData.lastShoot = 0;

    scene.add(enemy);
    enemies.push(enemy);
  }

  for(let i=0; i<10; i++) {
    createEnemy(
      (Math.random() - 0.5) * 160,
      (Math.random() - 0.5) * 160
    );
  }

  // Movement controls
  const keys = {};
  document.addEventListener('keydown', e => { keys[e.code] = true; });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  // Jump/gravity
  let canJump = false;
  const gravity = -30;
  let velocityY = 0;

  // Enter house UI
  const enterHint = document.getElementById('enterHint');

  function checkEnterHouse() {
    const pos = controls.getObject().position;
    let nearHouse = null;
    for(const house of houses) {
      const doorPos = new THREE.Vector3(house.position.x, 0, house.position.z + 3);
      if(pos.distanceTo(doorPos) < 2) {
        nearHouse = house;
        break;
      }
    }
    if(nearHouse && !player.isInsideHouse) {
      enterHint.textContent = 'Press E to enter house';
      player.currentHouseNearby = nearHouse;
    } else if(player.isInsideHouse) {
      enterHint.textContent = 'Press E to exit house';
      player.currentHouseNearby = player.currentHouse;
    } else {
      enterHint.textContent = '';
      player.currentHouseNearby = null;
    }
  }

  document.addEventListener('keydown', e => {
    if(e.code === 'KeyE' && player.currentHouseNearby) {
      if(!player.isInsideHouse) {
        controls.getObject().position.set(
          player.currentHouseNearby.position.x,
          player.height,
          player.currentHouseNearby.position.z
        );
        player.isInsideHouse = true;
        player.currentHouse = player.currentHouseNearby;
      } else {
        controls.getObject().position.set(
          player.currentHouse.position.x,
          player.height,
          player.currentHouse.position.z + 5
        );
        player.isInsideHouse = false;
        player.currentHouse = null;
      }
    }
  });

  // Health display
  const healthEl = document.getElementById('health');

  // Enemy behavior: chase and shoot
  const enemySpeed = 5;
  const enemyDamage = 5;
  const shootInterval = 1500;

  function enemyAI(delta) {
    const playerPos = controls.getObject().position;
    const now = performance.now();

    enemies.forEach(enemy => {
      const enemyPos = enemy.position;
      const dist = enemyPos.distanceTo(playerPos);

      if(enemy.userData.health <= 0 || dist > 200) {
        // Respawn enemy
        enemy.position.set(
          (Math.random() - 0.5) * 160,
          0,
          (Math.random() - 0.5) * 160
        );
        enemy.userData.health = 100;
        return;
      }

      // Move toward player if > 2 units
      if(dist > 2) {
        const dir = new THREE.Vector3().subVectors(playerPos, enemyPos).normalize();
        enemy.position.addScaledVector(dir, enemySpeed * delta);
      }

      // Shoot if close
      if(dist < 20 && now - enemy.userData.lastShoot > shootInterval) {
        player.health -= enemyDamage;
        if(player.health < 0) player.health = 0;
        healthEl.textContent = player.health;
        enemy.userData.lastShoot = now;
      }
    });
  }

  // Animation loop
  let prevTime = performance.now();
  function animate() {
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;

    // Movement input
    let direction = new THREE.Vector3();
    if(keys['KeyW']) direction.z -= 1;
    if(keys['KeyS']) direction.z += 1;
    if(keys['KeyA']) direction.x -= 1;
    if(keys['KeyD']) direction.x += 1;
    direction.normalize();

    // Fix inverted left-right
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    camDir.y = 0;
    camDir.normalize();

    const camRight = new THREE.Vector3();
    camRight.crossVectors(new THREE.Vector3(0, 1, 0), camDir).normalize();

    let velocity = new THREE.Vector3();
    velocity.addScaledVector(camDir, direction.z * player.speed);
    velocity.addScaledVector(camRight, direction.x * player.speed);

    // Gravity and jumping
    velocityY += gravity * delta;

    // Position update
    let pos = controls.getObject().position.clone();
    pos.x += velocity.x * delta;
    pos.z += velocity.z * delta;

    // Horizontal collisions
    if(!playerCollides(pos)) {
      controls.getObject().position.x = pos.x;
      controls.getObject().position.z = pos.z;
    }

    // Vertical movement
    let nextY = controls.getObject().position.y + velocityY * delta;
    if(nextY < player.height) {
      velocityY = 0;
      controls.getObject().position.y = player.height;
      canJump = true;
    } else {
      controls.getObject().position.y = nextY;
      canJump = false;
    }

    // Jump input
    if(keys['Space'] && canJump) {
      velocityY = player.jumpSpeed;
      canJump = false;
    }

    enemyAI(delta);
    checkEnterHouse();

    prevTime = time;
    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
})();
</script>

</body>
</html>
