<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emu.io - 3D FPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: "Segoe UI", sans-serif;
      background: #000;
    }
    canvas {
      display: block;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 5;
      color: white;
      font-size: 18px;
      display: flex;
      flex-direction: column;
      user-select: none;
    }
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 4px;
      height: 4px;
      background: white;
      margin-left: -2px;
      margin-top: -2px;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div>Health: <span id="healthText">100</span></div>
    <div>Ammo: <span id="ammoText">10 / 10</span></div>
  </div>
  <div id="crosshair"></div>
  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const hud = document.getElementById('hud');
    const healthText = document.getElementById('healthText');
    const ammoText = document.getElementById('ammoText');

    let scene, camera, renderer, controls, clock;
    let bullets = [], enemies = [];
    let health = 100, ammo = 10, maxAmmo = 10;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let canShoot = true;

    const objects = []; // for collisions

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 10);

      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);

      clock = new THREE.Clock();

      // Lighting
      const ambient = new THREE.AmbientLight(0x888888);
      const dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(10, 20, 10);
      scene.add(ambient, dir);

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      objects.push(floor);

      // Airsoft field barriers (jersey barriers)
      const barrierMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      const barrierGeo = new THREE.BoxGeometry(4, 1.5, 1.5);
      const barrierPositions = [
        [-20, 0.75, -10],
        [-16, 0.75, -10],
        [-12, 0.75, -10],
        [-8, 0.75, -10],
        [-4, 0.75, -10],
        [0, 0.75, -10],
        [4, 0.75, -10],
        [8, 0.75, -10],
        [12, 0.75, -10],
        [16, 0.75, -10],
        [20, 0.75, -10],
        // Add some vertical lines
        [-20, 0.75, -6],
        [-20, 0.75, -2],
        [-20, 0.75, 2],
        [-20, 0.75, 6],
        [-20, 0.75, 10],
        [20, 0.75, 6],
        [20, 0.75, 2],
        [20, 0.75, -2],
        [20, 0.75, -6],
        [20, 0.75, -10],
      ];
      barrierPositions.forEach(pos => {
        const b = new THREE.Mesh(barrierGeo, barrierMat);
        b.position.set(pos[0], pos[1], pos[2]);
        b.castShadow = true;
        b.receiveShadow = true;
        scene.add(b);
        objects.push(b);
      });

      // Simple houses (enterable, no roofs)
      const houseMat = new THREE.MeshStandardMaterial({ color: 0x886633, side: THREE.DoubleSide });
      const wallGeo = new THREE.PlaneGeometry(6, 3);

      // House 1 walls (open front)
      const house1Walls = [];
      const posX1 = -10, posZ1 = 10;
      // back wall
      const backWall1 = new THREE.Mesh(wallGeo, houseMat);
      backWall1.position.set(posX1, 1.5, posZ1 - 3);
      scene.add(backWall1);
      house1Walls.push(backWall1);
      objects.push(backWall1);
      // left wall
      const leftWall1 = new THREE.Mesh(wallGeo, houseMat);
      leftWall1.position.set(posX1 - 3, 1.5, posZ1);
      leftWall1.rotation.y = Math.PI / 2;
      scene.add(leftWall1);
      house1Walls.push(leftWall1);
      objects.push(leftWall1);
      // right wall
      const rightWall1 = new THREE.Mesh(wallGeo, houseMat);
      rightWall1.position.set(posX1 + 3, 1.5, posZ1);
      rightWall1.rotation.y = -Math.PI / 2;
      scene.add(rightWall1);
      house1Walls.push(rightWall1);
      objects.push(rightWall1);

      // House 2 walls (open front)
      const posX2 = 15, posZ2 = 20;
      const backWall2 = new THREE.Mesh(wallGeo, houseMat);
      backWall2.position.set(posX2, 1.5, posZ2 - 3);
      scene.add(backWall2);
      objects.push(backWall2);
      const leftWall2 = new THREE.Mesh(wallGeo, houseMat);
      leftWall2.position.set(posX2 - 3, 1.5, posZ2);
      leftWall2.rotation.y = Math.PI / 2;
      scene.add(leftWall2);
      objects.push(leftWall2);
      const rightWall2 = new THREE.Mesh(wallGeo, houseMat);
      rightWall2.position.set(posX2 + 3, 1.5, posZ2);
      rightWall2.rotation.y = -Math.PI / 2;
      scene.add(rightWall2);
      objects.push(rightWall2);

      // Windows (shoot-through)
      const windowMat = new THREE.MeshStandardMaterial({ color: 0x4444aa, opacity: 0.3, transparent: true });
      const windowGeo = new THREE.PlaneGeometry(2, 1.5);
      // Add windows on houses
      const win1 = new THREE.Mesh(windowGeo, windowMat);
      win1.position.set(posX1, 1.5, posZ1 - 2);
      scene.add(win1);
      const win2 = new THREE.Mesh(windowGeo, windowMat);
      win2.position.set(posX2, 1.5, posZ2 - 2);
      scene.add(win2);

      // Player Controls
      controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      // Lock pointer on click
      canvas.addEventListener('click', () => {
        if (!controls.isLocked) {
          controls.lock();
          hud.style.display = 'block';
        }
      });

      // Player weapon (gun)
      const gunMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      const gunGeo = new THREE.BoxGeometry(0.3, 0.2, 1);
      gun = new THREE.Mesh(gunGeo, gunMat);
      gun.position.set(0.5, -0.5, -1);
      camera.add(gun);

      // Enemies
      for(let i = 0; i < 5; i++) spawnEnemy();

      // Input listeners
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);

      window.addEventListener('resize', onWindowResize, false);
    }

    function spawnEnemy() {
      const enemyMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
      const enemyGeo = new THREE.BoxGeometry(1, 2, 1);
      const enemy = new THREE.Mesh(enemyGeo, enemyMat);
      // spawn enemies away from player start
      enemy.position.set(
        (Math.random() * 80) - 40,
        1,
        (Math.random() * 80) - 40
      );
      enemy.health = 100;
      scene.add(enemy);
      enemies.push(enemy);
    }

    function onKeyDown(event) {
      switch(event.code){
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'KeyR': reload(); break;
      }
    }
    function onKeyUp(event) {
      switch(event.code){
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
    }
    function onMouseDown(event) {
      if(event.button === 0 && controls.isLocked) { // left mouse click
        shoot();
      }
    }

    function reload() {
      ammo = maxAmmo;
      ammoText.textContent = `${ammo} / ${maxAmmo}`;
    }

    let lastShotTime = 0;
    function shoot() {
      if(ammo <= 0) return;
      const now = performance.now();
      if(now - lastShotTime < 300) return;
      lastShotTime = now;

      ammo--;
      ammoText.textContent = `${ammo} / ${maxAmmo}`;

      const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.userData.velocity = dir.multiplyScalar(2);
      scene.add(bullet);
      bullets.push(bullet);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Simple collision detection
    function checkCollisions(position) {
      const radius = 0.3; // player radius
      for(let obj of objects){
        const box = new THREE.Box3().setFromObject(obj);
        if(box.containsPoint(position)){
          return true;
        }
      }
      return false;
    }

    // Animate loop
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      // Movement speed
      const speed = 5;

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      if(moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
      if(moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

      // Calculate next position with velocity
      const nextPosition = controls.getObject().position.clone();
      nextPosition.x += velocity.x;
      nextPosition.z += velocity.z;

      // Check collision before moving
      if(!checkCollisions(new THREE.Vector3(nextPosition.x, controls.getObject().position.y, nextPosition.z))){
        controls.getObject().position.copy(nextPosition);
      } else {
        // stop velocity if collision
        velocity.x = 0;
        velocity.z = 0;
      }

      // Bullets movement & lifetime
      for(let i = bullets.length - 1; i >= 0; i--){
        let b = bullets[i];
        b.position.add(b.userData.velocity);
        if(b.position.length() > 200){
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        // Check bullet collision with enemies
        for(let j = enemies.length -1; j >= 0; j--){
          const enemy = enemies[j];
          if(b.position.distanceTo(enemy.position) < 1){
            enemy.health -= 50;
            scene.remove(b);
            bullets.splice(i,1);
            if(enemy.health <= 0){
              scene.remove(enemy);
              enemies.splice(j,1);
              // Respawn enemy after 5 seconds
              setTimeout(spawnEnemy, 5000);
            }
            break;
          }
        }
      }

      // Enemies behavior
      enemies.forEach(enemy => {
        let dirToPlayer = new THREE.Vector3().subVectors(controls.getObject().position, enemy.position);
        let distance = dirToPlayer.length();

        if(distance < 30){
          dirToPlayer.normalize();
          enemy.position.add(dirToPlayer.multiplyScalar(1.2 * delta)); // enemy speed

          if(distance < 10 && Math.random() < 0.01){
            // Enemy shoots player, damage every second or so
            health -= 5;
            if(health < 0) health = 0;
            healthText.textContent = health;
            if(health === 0) respawn();
          }
        }
      });

      renderer.render(scene, camera);
    }

    function respawn(){
      health = 100;
      healthText.textContent = health;
      controls.getObject().position.set(0, 1.6, 10);
      velocity.set(0,0,0);
    }
  </script>
</body>
</html>
