<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emu.io - FPS Game</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    user-select: none;
  }
  #mainMenu, #pauseMenu {
    position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
    background: linear-gradient(135deg, #222, #000);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 15px;
    z-index: 10;
  }
  button {
    background: #444;
    border: none;
    padding: 15px 30px;
    color: #eee;
    font-size: 20px;
    border-radius: 10px;
    cursor: pointer;
    width: 250px;
    transition: background-color 0.3s;
  }
  button:hover {
    background: #007acc;
  }
  #healthBarContainer {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 220px;
    height: 30px;
    border: 2px solid #900;
    border-radius: 8px;
    background: #300;
    display: none;
    user-select: none;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #ff0000, #800000);
    border-radius: 8px;
  }
  #healthText {
    position: absolute;
    top: 0; left: 50%; transform: translateX(-50%);
    font-weight: bold;
    color: white;
    line-height: 30px;
    font-size: 16px;
    pointer-events: none;
    user-select: none;
  }
  canvas {
    display: block;
  }
  #pauseMenu {
    display: none;
  }
</style>
</head>
<body>

<div id="mainMenu">
  <h1 style="font-size: 48px; margin-bottom: 40px; color:#eee;">Emu.io</h1>
  <div style="font-size: 22px; margin-bottom: 20px;">Select Map</div>
  <button class="mapBtn" data-map="0">Map 1 - Arena</button>
  <button class="mapBtn" data-map="1">Map 2 - Maze</button>
  <button class="mapBtn" data-map="2">Map 3 - Open Field</button>
</div>

<div id="pauseMenu">
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
  <button id="mainMenuBtn">Main Menu</button>
</div>

<div id="healthBarContainer">
  <div id="healthBar"></div>
  <div id="healthText">100</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>

<script>
(() => {
  // ==== Variables ====
  let scene, camera, renderer, controls;
  let player, playerVelocity = new THREE.Vector3();
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let canShoot = true;
  let shootCooldown = 0.5; // seconds between player shots
  let shootTimer = 0;
  let bullets = [];
  let enemies = [];
  let enemyBullets = [];
  let clock = new THREE.Clock();

  let playerHealth = 100;
  const maxHealth = 100;

  const enemyShootIntervalMin = 1.5;
  const enemyShootIntervalMax = 3.5;

  // UI Elements
  const mainMenu = document.getElementById('mainMenu');
  const pauseMenu = document.getElementById('pauseMenu');
  const healthBarContainer = document.getElementById('healthBarContainer');
  const healthBar = document.getElementById('healthBar');
  const healthText = document.getElementById('healthText');

  // Sounds
  let audioContext;
  let sounds = {};

  // Maps: simple platforms for demo
  const maps = [
    createMapArena,
    createMapMaze,
    createMapOpenField
  ];
  let currentMapIndex = 0;

  // ==== Init ====
  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101010);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.PointerLockControls(camera, document.body);

    // Player capsule
    const playerGeometry = new THREE.CapsuleGeometry(0.5, 1.0, 4, 8);
    const playerMaterial = new THREE.MeshStandardMaterial({color: 0x00aaff});
    player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.set(0, 1.5, 0);
    scene.add(player);

    // Attach camera to player (slightly above center)
    camera.position.set(0, 1.6, 0);
    player.add(camera);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Floor light for better visibility
    const floorLight = new THREE.PointLight(0xffffff, 0.7, 30);
    floorLight.position.set(0, 5, 0);
    scene.add(floorLight);

    window.addEventListener('resize', onWindowResize);

    // Movement controls
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // Shoot on mouse down
    document.addEventListener('mousedown', onMouseDown);

    // Pause menu ESC
    document.addEventListener('keydown', onKeyPause);

    // Init Audio
    initAudio();

    animate();
  }

  // ==== Map Creation Functions ====

  function createMapArena() {
    clearMap();

    // Big flat ground
    const floor = new THREE.Mesh(
      new THREE.BoxGeometry(50, 1, 50),
      new THREE.MeshStandardMaterial({color: 0x303030})
    );
    floor.position.set(0, -0.5, 0);
    scene.add(floor);

    // Walls around edges
    const wallMat = new THREE.MeshStandardMaterial({color: 0x555555});
    const thickness = 1;
    const height = 5;

    const walls = [
      new THREE.BoxGeometry(50, height, thickness),
      new THREE.BoxGeometry(50, height, thickness),
      new THREE.BoxGeometry(thickness, height, 50),
      new THREE.BoxGeometry(thickness, height, 50)
    ];
    const wallPositions = [
      [0, height/2, -25], // back
      [0, height/2, 25],  // front
      [-25, height/2, 0], // left
      [25, height/2, 0]   // right
    ];

    for(let i=0; i < walls.length; i++) {
      const wall = new THREE.Mesh(walls[i], wallMat);
      wall.position.set(...wallPositions[i]);
      scene.add(wall);
    }

    spawnEnemies(10);
  }

  function createMapMaze() {
    clearMap();

    // Floor
    const floor = new THREE.Mesh(
      new THREE.BoxGeometry(40, 1, 40),
      new THREE.MeshStandardMaterial({color: 0x282828})
    );
    floor.position.set(0, -0.5, 0);
    scene.add(floor);

    // Maze walls (simple grid walls)
    const wallMat = new THREE.MeshStandardMaterial({color: 0x444444});
    const wallGeo = new THREE.BoxGeometry(2, 4, 10);

    // Vertical walls
    for(let x = -15; x <= 15; x += 5) {
      for(let z of [-10, 0, 10]) {
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.set(x, 2, z);
        scene.add(wall);
      }
    }

    // Horizontal walls
    const hWallGeo = new THREE.BoxGeometry(10, 4, 2);
    for(let z = -15; z <= 15; z += 5) {
      for(let x of [-10, 0, 10]) {
        const wall = new THREE.Mesh(hWallGeo, wallMat);
        wall.position.set(x, 2, z);
        scene.add(wall);
      }
    }

    spawnEnemies(8);
  }

  function createMapOpenField() {
    clearMap();

    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(60, 60),
      new THREE.MeshStandardMaterial({color: 0x204020})
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Some random obstacles
    const boxGeo = new THREE.BoxGeometry(3, 3, 3);
    const boxMat = new THREE.MeshStandardMaterial({color: 0x335533});
    for(let i=0; i<12; i++) {
      const box = new THREE.Mesh(boxGeo, boxMat);
      box.position.set(
        Math.random()*50 - 25,
        1.5,
        Math.random()*50 - 25
      );
      scene.add(box);
    }

    spawnEnemies(12);
  }

  // Clear current map objects except player and lights
  function clearMap() {
    // Remove everything except player and lights
    for(let i = scene.children.length -1; i >= 0; i--) {
      const obj = scene.children[i];
      if(obj !== player && !(obj instanceof THREE.Light)) {
        scene.remove(obj);
      }
    }

    enemies.length = 0;
    bullets.length = 0;
    enemyBullets.length = 0;
  }

  // ==== Enemies ====

  function spawnEnemies(count) {
    const enemyGeometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
    const enemyMaterial = new THREE.MeshStandardMaterial({color: 0x222222});

    for(let i=0; i<count; i++) {
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      enemy.position.set(
        (Math.random()-0.5)*40,
        1.5,
        (Math.random()-0.5)*40
      );
      enemy.health = 100;
      enemy.lastShootTime = 0;
      enemy.shootCooldown = enemyShootIntervalMin + Math.random() * (enemyShootIntervalMax - enemyShootIntervalMin);
      scene.add(enemy);
      enemies.push(enemy);
    }
  }

  // ==== Controls ====

  function onKeyDown(event) {
    switch(event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = true;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = true;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = true;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = true;
        break;
    }
  }

  function onKeyUp(event) {
    switch(event.code) {
      case 'ArrowUp':
      case 'KeyW':
        moveForward = false;
        break;
      case 'ArrowLeft':
      case 'KeyA':
        moveLeft = false;
        break;
      case 'ArrowDown':
      case 'KeyS':
        moveBackward = false;
        break;
      case 'ArrowRight':
      case 'KeyD':
        moveRight = false;
        break;
    }
  }

  function onMouseDown(event) {
    if (!controls.isLocked) return;
    shoot();
  }

  // ==== Shooting ====

  function shoot() {
    if (!canShoot) return;
    canShoot = false;
    shootTimer = shootCooldown;

    // Bullet
    const bulletGeometry = new THREE.SphereGeometry(0.08, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

    // Position bullet at player's position + forward
    bullet.position.copy(player.position);
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    bullet.userData = {
      velocity: forward.multiplyScalar(60),
      owner: 'player'
    };

    scene.add(bullet);
    bullets.push(bullet);

    playSound('shoot');
  }

  // Enemy shooting (similar bullets)
  function enemyShoot(enemy) {
    // Bullet
    const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
    const bulletMaterial = new THREE.MeshBasicMaterial({color: 0x880000});
    const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

    bullet.position.copy(enemy.position);
    const dir = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
    bullet.userData = {
      velocity: dir.multiplyScalar(50),
      owner: 'enemy'
    };

    scene.add(bullet);
    enemyBullets.push(bullet);

    playSound('shoot');
  }

  // ==== Health and Damage ====

  function damagePlayer(amount) {
    playerHealth -= amount;
    if(playerHealth < 0) playerHealth = 0;
    updateHealthUI();

    playSound('hit');

    if(playerHealth <= 0) {
      playSound('death');
      respawnPlayer();
    }
  }

  function damageEnemy(enemy, amount) {
    enemy.health -= amount;
    if(enemy.health <= 0) {
      scene.remove(enemy);
      enemies.splice(enemies.indexOf(enemy), 1);
    }
  }

  function updateHealthUI() {
    const percent = playerHealth / maxHealth;
    healthBar.style.width = (percent * 100) + '%';
    healthText.textContent = Math.floor(playerHealth);
  }

  // ==== Respawn ====

  function respawnPlayer() {
    playerHealth = maxHealth;
    updateHealthUI();
    // Reset player position
    player.position.set(0, 1.5, 0);
    playerVelocity.set(0,0,0);
  }

  // ==== Animation Loop ====

  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    if(controls.isLocked && !isPaused) {
      // Movement speed
      const speed = 10;

      // Move player velocity
      playerVelocity.set(0,0,0);
      if(moveForward) playerVelocity.z -= speed * delta;
      if(moveBackward) playerVelocity.z += speed * delta;
      if(moveLeft) playerVelocity.x -= speed * delta;
      if(moveRight) playerVelocity.x += speed * delta;

      // Apply movement in local space
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.y = 0; dir.normalize();

      const right = new THREE.Vector3();
      right.crossVectors(camera.up, dir).normalize();

      player.position.add(dir.multiplyScalar(-playerVelocity.z));
      player.position.add(right.multiplyScalar(playerVelocity.x));

      // Keep player above ground
      if(player.position.y < 1.5) player.position.y = 1.5;

      // Bullets move
      for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i];
        b.position.addScaledVector(b.userData.velocity, delta);

        // Check collision with enemies
        for(let enemy of enemies) {
          if(b.position.distanceTo(enemy.position) < 1) {
            damageEnemy(enemy, 34);
            scene.remove(b);
            bullets.splice(i,1);
            break;
          }
        }

        // Remove bullets if far away
        if(b.position.distanceTo(player.position) > 100) {
          scene.remove(b);
          bullets.splice(i,1);
        }
      }

      // Enemy behavior
      for(let enemy of enemies) {
        // Move toward player
        const toPlayer = new THREE.Vector3().subVectors(player.position, enemy.position);
        toPlayer.y = 0;
        if(toPlayer.length() > 2) {
          toPlayer.normalize();
          enemy.position.addScaledVector(toPlayer, delta * 2.5);
        }

        // Shooting logic - random intervals
        enemy.lastShootTime += delta;
        if(enemy.lastShootTime > enemy.shootCooldown) {
          if(Math.random() < 0.7) {
            enemyShoot(enemy);
          }
          enemy.lastShootTime = 0;
          enemy.shootCooldown = enemyShootIntervalMin + Math.random() * (enemyShootIntervalMax - enemyShootIntervalMin);
        }
      }

      // Enemy bullets move
      for(let i=enemyBullets.length-1; i>=0; i--) {
        let b = enemyBullets[i];
        b.position.addScaledVector(b.userData.velocity, delta);

        // Check collision with player
        if(b.position.distanceTo(player.position) < 1) {
          damagePlayer(10);
          scene.remove(b);
          enemyBullets.splice(i,1);
          continue;
        }

        // Remove bullets if far away
        if(b.position.distanceTo(player.position) > 100) {
          scene.remove(b);
          enemyBullets.splice(i,1);
        }
      }

      // Shooting cooldown
      if(!canShoot) {
        shootTimer -= delta;
        if(shootTimer <= 0) canShoot = true;
      }
    }

    renderer.render(scene, camera);
  }

  // ==== Window resize ====

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // ==== Audio ====

  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // Create simple beep sounds for shoot, hit, death
      sounds.shoot = createBeep(1000, 0.05);
      sounds.hit = createBeep(400, 0.1);
      sounds.death = createBeep(200, 0.3);
    } catch(e) {
      console.warn("Web Audio API not supported.");
    }
  }

  function createBeep(freq, duration) {
    return function() {
      if(!audioContext) return;
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      osc.connect(gainNode);
      gainNode.connect(audioContext.destination);

      osc.frequency.value = freq;
      osc.type = 'square';

      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      osc.start();
      osc.stop(audioContext.currentTime + duration);

      osc.onended = () => {
        gainNode.disconnect();
        osc.disconnect();
      };
    }
  }

  function playSound(name) {
    if(sounds[name]) sounds[name]();
  }

  // ==== Pause / Resume ====

  let isPaused = false;

  function onKeyPause(e) {
    if(e.code === 'Escape') {
      if(controls.isLocked && !isPaused) {
        pauseGame();
      } else if(isPaused) {
        resumeGame();
      }
    }
  }

  function pauseGame() {
    isPaused = true;
    controls.unlock();
    pauseMenu.style.display = 'flex';
    healthBarContainer.style.display = 'none';
  }

  function resumeGame() {
    isPaused = false;
    controls.lock();
    pauseMenu.style.display = 'none';
    healthBarContainer.style.display = 'block';
  }

  // ==== Main Menu buttons ====

  document.querySelectorAll('.mapBtn').forEach(btn => {
    btn.addEventListener('click', () => {
      currentMapIndex = parseInt(btn.dataset.map);
      mainMenu.style.display = 'none';
      healthBarContainer.style.display = 'block';
      initMap(currentMapIndex);
      controls.lock();
    });
  });

  document.getElementById('resumeBtn').addEventListener('click', () => {
    resumeGame();
  });

  document.getElementById('mainMenuBtn').addEventListener('click', () => {
    pauseMenu.style.display = 'none';
    healthBarContainer.style.display = 'none';
    mainMenu.style.display = 'flex';
    isPaused = false;
    controls.unlock();
    clearMap();
    resetPlayerAndVars();
  });

  // ==== Initialize selected map ====

  function initMap(index) {
    clearMap();
    maps[index]();
    resetPlayerAndVars();
  }

  function resetPlayerAndVars() {
    player.position.set(0, 1.5, 0);
    playerHealth = maxHealth;
    updateHealthUI();
    bullets.forEach(b => scene.remove(b));
    bullets.length = 0;
    enemyBullets.forEach(b => scene.remove(b));
    enemyBullets.length = 0;
  }

  // ==== Start ====

  init();

})();
</script>

</body>
</html>
