<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emu.io - Container Map FPS</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      height: 100%; background-color: #222;
      font-family: Arial, sans-serif;
      color: white;
      user-select: none;
    }
    #hud {
      position: absolute;
      top: 20px; left: 20px;
      z-index: 10;
      font-size: 18px;
      background: rgba(0,0,0,0.4);
      padding: 8px 12px;
      border-radius: 6px;
    }
    #crosshair {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 4px;
      height: 4px;
      background: white;
      margin-left: -2px;
      margin-top: -2px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="hud">
    Health: <span id="healthText">100</span><br />
    Ammo: <span id="ammoText">10 / 10</span><br />
    Press W/A/S/D to move, Left Click to shoot, R to reload.
  </div>
  <div id="crosshair"></div>
  <canvas id="gameCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/PointerLockControls.js"></script>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const healthText = document.getElementById('healthText');
    const ammoText = document.getElementById('ammoText');

    let scene, camera, renderer, controls, clock;
    let bullets = [], enemies = [];
    let health = 100, ammo = 10, maxAmmo = 10;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let canShoot = true;

    const objects = []; // collision objects

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 10);

      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);

      clock = new THREE.Clock();

      // Lights
      const ambientLight = new THREE.AmbientLight(0x888888);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 20, 10);
      scene.add(ambientLight, directionalLight);

      // Floor
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
      objects.push(floor);

      // Container map (shipment style)
      const containerColors = [0x008080, 0x004040, 0x006666];
      const containerGeo = new THREE.BoxGeometry(4, 2.5, 12);
      // Arrange containers in rows
      const containerPositions = [
        [-20, 1.25, -20],
        [-14, 1.25, -20],
        [-8, 1.25, -20],
        [-2, 1.25, -20],
        [4, 1.25, -20],
        [10, 1.25, -20],
        [16, 1.25, -20],

        [-20, 1.25, -6],
        [-14, 1.25, -6],
        [-8, 1.25, -6],
        [-2, 1.25, -6],
        [4, 1.25, -6],
        [10, 1.25, -6],
        [16, 1.25, -6],

        [-20, 1.25, 8],
        [-14, 1.25, 8],
        [-8, 1.25, 8],
        [-2, 1.25, 8],
        [4, 1.25, 8],
        [10, 1.25, 8],
        [16, 1.25, 8],
      ];

      containerPositions.forEach((pos, i) => {
        const mat = new THREE.MeshStandardMaterial({ color: containerColors[i % containerColors.length] });
        const container = new THREE.Mesh(containerGeo, mat);
        container.position.set(...pos);
        scene.add(container);
        objects.push(container);
      });

      // Player Controls (PointerLockControls)
      controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());

      // Lock pointer on click
      canvas.addEventListener('click', () => {
        if (!controls.isLocked) {
          controls.lock();
        }
      });

      // Gun model
      const gunMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      const gunGeo = new THREE.BoxGeometry(0.3, 0.2, 1);
      gun = new THREE.Mesh(gunGeo, gunMat);
      gun.position.set(0.5, -0.5, -1);
      camera.add(gun);

      // Spawn enemies
      for(let i = 0; i < 5; i++) spawnEnemy();

      // Input listeners
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);

      window.addEventListener('resize', onWindowResize, false);
    }

    function spawnEnemy() {
      const enemyMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
      const enemyGeo = new THREE.BoxGeometry(1, 2, 1);
      const enemy = new THREE.Mesh(enemyGeo, enemyMat);
      enemy.position.set(
        (Math.random() * 80) - 40,
        1,
        (Math.random() * 80) - 40
      );
      enemy.health = 100;
      scene.add(enemy);
      enemies.push(enemy);
    }

    function onKeyDown(event) {
      switch(event.code){
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'KeyR': reload(); break;
      }
    }
    function onKeyUp(event) {
      switch(event.code){
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
    }
    function onMouseDown(event) {
      if(event.button === 0 && controls.isLocked) { // left click shoot
        shoot();
      }
    }

    function reload() {
      ammo = maxAmmo;
      ammoText.textContent = `${ammo} / ${maxAmmo}`;
    }

    let lastShotTime = 0;
    function shoot() {
      if(ammo <= 0) return;
      const now = performance.now();
      if(now - lastShotTime < 300) return;
      lastShotTime = now;

      ammo--;
      ammoText.textContent = `${ammo} / ${maxAmmo}`;

      const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.position.copy(camera.position);
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      bullet.userData.velocity = dir.multiplyScalar(2);
      scene.add(bullet);
      bullets.push(bullet);
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function checkCollisions(position) {
      const radius = 0.3; // player radius
      for(let obj of objects){
        const box = new THREE.Box3().setFromObject(obj);
        if(box.containsPoint(position)){
          return true;
        }
      }
      return false;
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const speed = 5;

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      // Movement vector relative to camera direction (corrected)
      let forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      let right = new THREE.Vector3();
      right.crossVectors(forward, camera.up);

      direction = new THREE.Vector3();
      if(moveForward) direction.add(forward);
      if(moveBackward) direction.sub(forward);
      if(moveRight) direction.add(right);
      if(moveLeft) direction.sub(right);
      direction.normalize();

      if(direction.length() > 0) {
        velocity.x -= direction.x * speed * delta;
        velocity.z -= direction.z * speed * delta;
      }

      const nextPosition = controls.getObject().position.clone();
      nextPosition.x += velocity.x;
      nextPosition.z += velocity.z;

      if(!checkCollisions(new THREE.Vector3(nextPosition.x, controls.getObject().position.y, nextPosition.z))){
        controls.getObject().position.copy(nextPosition);
      } else {
        velocity.x = 0;
        velocity.z = 0;
      }

      // Bullets move
      for(let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity);
        if(b.position.length() > 200){
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        for(let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if(b.position.distanceTo(enemy.position) < 1) {
            enemy.health -= 50;
            scene.remove(b);
            bullets.splice(i, 1);
            if(enemy.health <= 0) {
              scene.remove(enemy);
              enemies.splice(j, 1);
              setTimeout(spawnEnemy, 5000);
            }
            break;
          }
        }
      }

      // Enemy AI
      enemies.forEach(enemy => {
        let dirToPlayer = new THREE.Vector3().subVectors(controls.getObject().position, enemy.position);
        let dist = dirToPlayer.length();
        if(dist < 30){
          dirToPlayer.normalize();
          enemy.position.add(dirToPlayer.multiplyScalar(1.2 * delta));
          if(dist < 10 && Math.random() < 0.01){
            health -= 5;
            if(health < 0) health = 0;
            healthText.textContent = health;
            if(health === 0) respawn();
          }
        }
      });

      renderer.render(scene, camera);
    }

    function respawn(){
      health = 100;
      healthText.textContent = health;
      controls.getObject().position.set(0, 1.6, 10);
      velocity.set(0, 0, 0);
    }
  </script>
</body>
</html>
